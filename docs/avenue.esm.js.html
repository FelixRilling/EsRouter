<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>avenue.esm.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Avenue.html">Avenue</a><ul class='methods'><li data-type='method'><a href="Avenue.html#getView">getView</a></li><li data-type='method'><a href="Avenue.html#setView">setView</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">avenue.esm.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Checks if a value is an array.
 *
 * Alias of the native `Array.isArray`.
 *
 * @function isArray
 * @memberof Is
 * @since 1.0.0
 * @param {any} val
 * @returns {boolean}
 * @example
 * isArray([1, 2, 3]);
 * // => true
 *
 * isArray({});
 * // => false
 */

/**
 * Iterates over each entry of an object.
 *
 * @function forEachEntry
 * @memberof For
 * @param {object} obj
 * @param {function} fn fn(key: *, val: *, index: number, arr: any[])
 * @example
 * const a = {a: 1, b: 2};
 *
 * forEachEntry(a, (key, val, index) => {
 *     a[key] = val * index;
 * })
 * // a = {a: 0, b: 2}
 */
const forEachEntry = (obj, fn) => {
    Object.entries(obj).forEach((entry, index) => {
        fn(entry[0], entry[1], index, obj);
    });
};

/**
 * Returns hash without init-character.
 *
 * @private
 * @returns {string} current location hash, without the hash.
 */
const getLocationHash = () => location.hash.replace("#", "");

/**
 * Splits path by slashes and trims.
 *
 * @private
 * @param {string} pathStr path string.
 * @returns {Array&lt;string>} trimmed path string array.
 */
const splitPath = (path) => path.split("/").filter(item => item.length);

/**
 * Checks if the pathPart is a path variable.
 *
 * @private
 * @param {string} path path string.
 * @returns {boolean} if the pathPart is a path variable.
 */
const isPathVariable = (pathPart) => pathPart[0] === ":";
/**
 * Checks if two routes match.
 *
 * @private
 * @param {Array&lt;string>} currentPath first route.
 * @param {Array&lt;string>} routePath second route.
 * @returns {boolean} if the first and second route match.
 */
const matchRoutes = (currentPath, routePath) => currentPath.every((currentPathPart, index) => {
    const routePathPart = routePath[index];
    if (routePathPart) {
        // Checks for variable-wildcard or equivalency
        return (isPathVariable(routePathPart) ||
            currentPathPart === routePathPart);
    }
    return false;
});
/**
 * Finds route by path.
 *
 * @private
 * @param {Array&lt;string>} path path string array.
 * @param {object} routes object containing routes.
 * @returns {object|null} object containing route and args, or null if none was found.
 */
const findRoute = (path, routes) => {
    const route = routes.find((routeCurrent) => matchRoutes(path, routeCurrent[0]));
    if (route) {
        const args = {};
        route[0].forEach((routePathPart, index) => {
            if (isPathVariable(routePathPart)) {
                args[routePathPart.substr(1)] = path[index];
            }
        });
        return {
            route,
            args
        };
    }
    return null;
};

/**
 * Avenue class.
 *
 * @class
 */
const Avenue = class {
    /**
     * Avenue constructor.
     *
     * @constructor
     * @param {object} routes object of routes to use.
     */
    constructor(routes) {
        this.view = null;
        this.routes = [];
        this.fallback = () => { };
        // Change routes from {string: fn} to [string[], fn] and extract fallback route
        forEachEntry(routes, (routeItemPath, routeItemFn) => {
            if (routeItemPath === "?") {
                this.fallback = routeItemFn;
            }
            else {
                this.routes.push([splitPath(routeItemPath), routeItemFn]);
            }
        });
        window.addEventListener("hashchange", e => this.setView(getLocationHash(), e), false);
        // Load current route if exists
        this.setView(getLocationHash());
    }
    /**
     * Sets view to a route path.
     *
     * @param {string} path string route path.
     * @param {Event|null} [e=null] event, if called through one.
     */
    setView(path, e = null) {
        const result = findRoute(splitPath(path), this.routes);
        if (result) {
            this.view = path;
            result.route[1](result.args, path, e);
        }
        else {
            this.fallback({}, path, e);
        }
    }
    /**
     * Returns active view path.
     *
     * @returns {string|null} active view, or null if none was set.
     */
    getView() {
        return this.view;
    }
};

export default Avenue;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sat Sep 29 2018 12:07:37 GMT+0200 (Central European Summer Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>


</body>
</html>
